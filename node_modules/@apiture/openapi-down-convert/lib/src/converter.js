"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Converter = void 0;
const v8 = require("v8");
const yaml = require("js-yaml");
const fs = require("fs");
const RefVisitor_1 = require("./RefVisitor");
class Converter {
    constructor(openapiDocument, options) {
        this.verbose = false;
        this.deleteExampleWithId = false;
        this.allOfTransform = false;
        this.scopeDescriptions = undefined;
        this.openapi30 = Converter.deepClone(openapiDocument);
        this.verbose = Boolean(options === null || options === void 0 ? void 0 : options.verbose);
        this.deleteExampleWithId = Boolean(options === null || options === void 0 ? void 0 : options.deleteExampleWithId);
        this.allOfTransform = Boolean(options === null || options === void 0 ? void 0 : options.allOfTransform);
        this.authorizationUrl = (options === null || options === void 0 ? void 0 : options.authorizationUrl) || 'https://www.example.com/oauth2/authorize';
        this.tokenUrl = (options === null || options === void 0 ? void 0 : options.tokenUrl) || 'https://www.example.com/oauth2/token';
        this.loadScopeDescriptions(options === null || options === void 0 ? void 0 : options.scopeDescriptionFile);
    }
    loadScopeDescriptions(scopeDescriptionFile) {
        if (!scopeDescriptionFile) {
            return;
        }
        this.scopeDescriptions = yaml.load(fs.readFileSync(scopeDescriptionFile, 'utf8'));
    }
    log(...message) {
        if (this.verbose) {
            this.warn(...message);
        }
    }
    warn(...message) {
        if (!message[0].startsWith('Warning')) {
            message[0] = `Warning: ${message[0]}`;
        }
        console.warn(...message);
    }
    convert() {
        this.log('Converting from OpenAPI 3.1 to 3.0');
        this.openapi30.openapi = '3.0.3';
        this.removeLicenseIdentifier();
        this.convertSchemaRef();
        this.simplifyNonSchemaRef();
        if (this.scopeDescriptions) {
            this.convertSecuritySchemes();
        }
        this.convertJsonSchemaExamples();
        this.convertConstToEnum();
        this.convertNullableTypeArray();
        this.removeUnsupportedSchemaKeywords();
        return this.openapi30;
    }
    convertJsonSchemaExamples() {
        const schemaVisitor = (schema) => {
            for (const key in schema) {
                const subSchema = schema[key];
                if (subSchema !== null && typeof subSchema === 'object') {
                    if (key === 'examples') {
                        const examples = schema['examples'];
                        if (Array.isArray(examples) && examples.length > 0) {
                            delete schema['examples'];
                            const first = examples[0];
                            if (this.deleteExampleWithId &&
                                first != null &&
                                typeof first === 'object' &&
                                first.hasOwnProperty('id')) {
                                this.log(`Deleted schema example with \`id\` property:\n${this.json(examples)}`);
                            }
                            else {
                                schema['example'] = first;
                                this.log(`Replaces examples with examples[0]. Old examples:\n${this.json(examples)}`);
                            }
                        }
                    }
                    else {
                        schema[key] = (0, RefVisitor_1.walkObject)(subSchema, schemaVisitor);
                    }
                }
            }
            return schema;
        };
        (0, RefVisitor_1.visitSchemaObjects)(this.openapi30, schemaVisitor);
    }
    walkNestedSchemaObjects(schema, schemaVisitor) {
        for (const key in schema) {
            const subSchema = schema[key];
            if (subSchema !== null && typeof subSchema === 'object') {
                schema[key] = (0, RefVisitor_1.walkObject)(subSchema, schemaVisitor);
            }
        }
        return schema;
    }
    convertConstToEnum() {
        const schemaVisitor = (schema) => {
            if (schema['const']) {
                const constant = schema['const'];
                delete schema['const'];
                schema['enum'] = [constant];
                this.log(`Converted const: ${constant} to enum`);
            }
            return this.walkNestedSchemaObjects(schema, schemaVisitor);
        };
        (0, RefVisitor_1.visitSchemaObjects)(this.openapi30, schemaVisitor);
    }
    convertNullableTypeArray() {
        const schemaVisitor = (schema) => {
            if (schema.hasOwnProperty('type')) {
                const schemaType = schema['type'];
                if (Array.isArray(schemaType) && schemaType.length === 2 && schemaType.includes('null')) {
                    const nonNull = schemaType.filter((_) => _ !== 'null')[0];
                    schema['type'] = nonNull;
                    schema['nullable'] = true;
                    this.log(`Converted schema type array to nullable`);
                }
            }
            return this.walkNestedSchemaObjects(schema, schemaVisitor);
        };
        (0, RefVisitor_1.visitSchemaObjects)(this.openapi30, schemaVisitor);
    }
    removeUnsupportedSchemaKeywords() {
        const keywordsToRemove = ['$id', '$schema', 'unevaluatedProperties'];
        const schemaVisitor = (schema) => {
            keywordsToRemove.forEach((key) => {
                if (schema.hasOwnProperty(key)) {
                    delete schema[key];
                    this.log(`Removed unsupported schema keyword ${key}`);
                }
            });
            return this.walkNestedSchemaObjects(schema, schemaVisitor);
        };
        (0, RefVisitor_1.visitSchemaObjects)(this.openapi30, schemaVisitor);
    }
    json(x) {
        return JSON.stringify(x, null, 2);
    }
    convertSecuritySchemes() {
        var _a, _b;
        const oauth2Scopes = (schemeName) => {
            var _a;
            const scopes = {};
            const paths = (_a = this.openapi30) === null || _a === void 0 ? void 0 : _a.paths;
            for (const path in paths) {
                for (const op in paths[path]) {
                    if (op === 'parameters') {
                        continue;
                    }
                    const operation = paths[path][op];
                    const sec = operation === null || operation === void 0 ? void 0 : operation.security;
                    sec.forEach((s) => {
                        const requirement = s === null || s === void 0 ? void 0 : s[schemeName];
                        if (requirement) {
                            requirement.forEach((scope) => {
                                scopes[scope] = this.scopeDescriptions[scope] || `TODO: describe the '${scope}' scope`;
                            });
                        }
                    });
                }
            }
            return scopes;
        };
        const schemes = ((_b = (_a = this.openapi30) === null || _a === void 0 ? void 0 : _a.components) === null || _b === void 0 ? void 0 : _b['securitySchemes']) || {};
        for (const schemeName in schemes) {
            const scheme = schemes[schemeName];
            const type = scheme.type;
            if (type === 'openIdConnect') {
                this.log(`Converting openIdConnect security scheme to oauth2/authorizationCode`);
                scheme.type = 'oauth2';
                const openIdConnectUrl = scheme.openIdConnectUrl;
                scheme.description = `OAuth2 Authorization Code Flow. The client may
          GET the OpenID Connect configuration JSON from \`${openIdConnectUrl}\`
          to get the correct \`authorizationUrl\` and \`tokenUrl\`.`;
                delete scheme.openIdConnectUrl;
                const scopes = oauth2Scopes(schemeName);
                scheme.flows = {
                    authorizationCode: {
                        authorizationUrl: this.authorizationUrl,
                        tokenUrl: this.tokenUrl,
                        scopes: scopes,
                    },
                };
            }
        }
    }
    simplifyNonSchemaRef() {
        (0, RefVisitor_1.visitRefObjects)(this.openapi30, (node) => {
            if (Object.keys(node).length === 1) {
                return node;
            }
            else {
                this.log(`Down convert reference object to JSON Reference:\n${JSON.stringify(node, null, 3)}`);
                Object.keys(node)
                    .filter((key) => key !== '$ref')
                    .forEach((key) => delete node[key]);
                return node;
            }
        });
    }
    removeLicenseIdentifier() {
        var _a, _b, _c;
        if ((_c = (_b = (_a = this.openapi30) === null || _a === void 0 ? void 0 : _a['info']) === null || _b === void 0 ? void 0 : _b['license']) === null || _c === void 0 ? void 0 : _c['identifier']) {
            this.log(`Removed info.license.identifier: ${this.openapi30['info']['license']['identifier']}`);
            delete this.openapi30['info']['license']['identifier'];
        }
    }
    convertSchemaRef() {
        const simplifyRefObjectsInSchemas = (object) => {
            return (0, RefVisitor_1.visitRefObjects)(object, (node) => {
                if (Object.keys(node).length === 1) {
                    return node;
                }
                else {
                    this.log(`Converting JSON Schema $ref ${this.json(node)} to allOf: [ $ref ]`);
                    node['allOf'] = [{ $ref: node.$ref }];
                    delete node.$ref;
                    return node;
                }
            });
        };
        if (this.allOfTransform) {
            (0, RefVisitor_1.visitSchemaObjects)(this.openapi30, (schema) => {
                return simplifyRefObjectsInSchemas(schema);
            });
        }
    }
    static deepClone(obj) {
        return v8.deserialize(v8.serialize(obj));
    }
}
exports.Converter = Converter;
//# sourceMappingURL=converter.js.map